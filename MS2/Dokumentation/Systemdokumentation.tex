\chapter{Systemdokumentation}

\section{Iteration der Kommunikationsmodelle}

Im Konzept haben wir bereits ein deskriptives und ein präskripives Kommunikationsmodell präsentiert. Durch den Projektfortschritt können diese nochmal bearbeitet und verbessert werden. Diesen Prozess werden wir nachfolgend für die beiden Modelle dokumentieren.

\subsection{Deskriptives Modell}

Ein wichtiger Punkt bei der Verbesserung des Kommunikationsmodells war der zeitliche Ablauf. Dieser wurde in der ersten Version des Modells nicht beachtet. Deshalb war der erste Schritt, diesen Ablauf mit einer Numerierung der übermittelten Daten bzw. Aktionen deutlich zu machen. Der zweite wichtige Punkt war, dass alle Interaktionen als Aktionen formuliert waren und kein Fokus auf die übermittelten Daten gelegt wurde. Deshalb haben wir die einzelnen Interaktionen so umformuliert, dass möglichst nur noch die übermittelten Daten angegeben sind. Da wir aber nicht komplett auf Aktionen verzichten wollten, haben wir diese kursiv im Modell dargestellt, damit die Daten sich von diesen abheben können. Das neue Modell wird in Abbildung ~\ref{komm1} dargestellt.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.85\linewidth]{Kommunikationsdiagramm1}
\caption{Deskriptives Kommunikationsmodell}
\label{komm1}
\end{figure}

\subsection{Präskriptives Modell}

Beim präskriptiven Modell haben wir dementsprechend die gleichen Änderungen vorgenommen. Zusätzlich wurde noch die Benutzer-ID eingeführt, mit der der Fachhändler gezielt über das System auf die Daten des Kunden zugreifen kann. Diese Benutzer-ID wird nach dem ersten Benutzen des Systems an den Benutzer gegeben und dieser muss sie dann an den Fachhändler weiter geben. Das neue präskriptive Modell kann in Abbildung ~\ref{komm2} angesehen werden.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.85\linewidth]{Kommunikationsdiagramm2}
\caption{Präskriptives Kommunikationsmodell}
\label{komm2}
\end{figure}

\section{Iteration des Architekturmodells}

Auch das Architekturmodell haben wir nochmal leicht verändert. Da es sich um eine Client-Server Architektur handelt und klar werden sollte, von welcher Seite eine Anfrage kommt und wohin die Antwort geschickt wird, haben wir die Doppelpfeile zwischen den Clients und dem Server aufgeteilt und mit Request bzw. Response beschriftet. Diese Änderung kann in Abbildung ~\ref{architektur} gesehen werden.
\\ \\
Da bei uns im Konzept noch die Herleitung bzw. der Bezug zum präskriptiven Kommunikationsmodell gefehlt hat, werden wir das an dieser Stelle nachholen. Wie man im Kommunikationsmodell sehen kann, gibt es abgesehen von den Wissenschaftlern zwei Akteure, die miteinander kommunizieren. Diese beiden Akteure, also normaler Benutzer und die Fachhandlung, lassen sich auch im Architekturmodell wiederfinden. Genau wie im Kommunikationsmodell gibt es bis auf die Übermittlung der Wasserprobe und der Beratung bzgl. Verbesserungen und Neuanschaffungen keine direkte Kommunikation zwischen den Akteuren, sondern nur über das System bzw. den Server. Und zwar läuft das genau so ab, dass ein Akteur eine Anfrage an den Server schickt und daraufhin eine Antwort bekommt. Wenn der Fachhändler etwas an den Kunden schicken möchte, geht das an den Server und mit Hilfe des Firebase Cloud Messaging wird das dann weiter an den Kunden geschickt und daraufhin bekommt der Fachhändler eine Antwort, ob die Aktion erfolgreich war.

\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{Architektur}
\caption{Architekturmodell}
\label{architektur}
\end{figure}

\section{Anwendungslogik}

Im Folgenden möchten wir nun näher auf die Anwendungslogik der jeweiligen Clients eingehen. 

\subsection{Benutzer Client}

Die Anwendungslogik des Benutzer Clients besteht aus den verschiedenen Berechnungen, die der Nutzer anhand seiner Aquarium Daten und seiner Wasserwerte durchführen kann. Diese werden wir zuerst in einer Übersicht auflisten und danach genauer beschreiben.

\begin{itemize}
\item Düngerdosierung
\item Zielgerichteten Wasserwechsel
\item Täglicher Nährstoffverbrauch
\item Gesamthärte
\item CO\textsubscript{2}-Gehalt
\item Tägliche Nährstoffveränderungen
\end{itemize}

\subsubsection{Düngerdosierung}

Um die Qualität seiner Pflanzen zu verbessern und gleichzeitig die Verbreitung von Algen zu vermindern, ist eine optimale Düngerdosierung erforderlich. Diese hängt von folgenden Faktoren ab: Beckenvolumen, CO\textsubscript{2}-Versorgung, Beleuchtung und Pflanzenmasse. Bei dieser Berechnung muss der Benutzer also in der Regel keine zusätzlichen Angaben mehr machen, da das Beckenvolumen durch die Größe seines Aquariums berechnet werden kann, welche er bereits beim Eintragen seines virtuellen Aquariums angegeben haben sollte. Außerdem sollte er bereits seine Pflanzen sowie ein mögliches CO\textsubscript{2}-Versorgungsgerät und die Beleuchtung zum virtuellen Aquarium hinzugefügt haben. Auf diese Werte kann das System also für die Berechnung zugreifen.

\subsubsection{Zielgerichteter Wasserwechsel}

\subsubsection{Täglicher Nährstoffverbrauch}

\subsubsection{Gesamthärte}

\subsubsection{CO\textsubscript{2}-Gehalt}

Kohlendioxid (CO\textsubscript{2}) wird von den Pflanzen aufgenommen und ist deren wichtigster Aufbaustoff. Der CO\textsubscript{2} Bedarf hängt von verschiedenen Faktoren ab. Somit hat jedes Aquarium seinen individuellen CO\textsubscript{2} Bedarf. Ein Aquarium mit vielen Pflanzen hat zum Beispiel einen hohen Bedarf an CO\textsubscript{2}. Eine hohe Anzahl von Fischen senkt hingegen den Bedarf. Somit ist es wichtig, den aktuellen CO\textsubscript{2}-Gehalt mit ausreichender Genauigkeit zu berechnen, um ggf. Anpassungen vornehmen zu können. Zur Berechnung benötigt man den pH-Wert und die Karbonathärte (KH). Diese kann man in der Regel schon mit einem einfachen Tröpfchentest ermitteln. Alternativ kann der Benutzer diese auch von seiner Fachhandlung bestimmen lassen. Mit folgender Formel lässt sich der CO\textsubscript{2}-Gehalt abschätzen \autocite{Formel:CO2}:

\begin{equation}
CO\textsubscript{2} = (KH/2,8)\cdot10^{(7,90-pH)}
\end{equation}

\subsubsection{Tägliche Nährstoffveränderungen}

\subsection{Fachhandlung Client}

\section{Architekturmerkmale}

\subsection{Ressourcen}

In unserem System gibt es drei wichtige Ressourcen, die über den Server ausgetauscht werden. Das sind die Benutzer, die virtuellen Aquarien und die Wasserwerte. Nachfolgend werden wir genauer auf die drei Ressourcen eingehen.

\subsubsection{Benutzer}

Die Benutzerinformationen werden in unserer Datenbank unter der MongoDB-Collection ``users'' gespeichert. Das Schema eines Benutzers wird wie folgt aussehen:

\begin{lstlisting}
   user{
      id: Number,
      token: String,
      vorname: String,
      nachname: String,
      geburtsdatum: Date,
      strasse: String,
      hausnummer: String,
      stadt: String,
      plz: Number
   }
\end{lstlisting}
 
Die ID ist eine fortlaufende Nummer, die automatisch generiert wird, um den Benutzer eindeutig identifizieren zu können. Der Token wird für das Firebase Cloud Messaging benötigt. Sobald der Benutzer das erste mal die App startet, wird dieser Token generiert und an den Server geschickt. Mit diesem Token können dann die Nachrichten der Fachhändler einem Benutzer zugeordnet werden. Theoretisch könnte man den Benutzer auch mit diesem Token eindeutig identifizieren, allerdings ist er ziemlich lang und somit haben wir uns noch für eine zusätzliche ID entschieden. Diese ID wird dem Benutzer angezeigt und diese muss er dann an seinen Fachhändler weitergeben, damit er den Kunden zu seinem System hinzufügen kann. Alle weiteren Attribute sind freiwillig, allerdings wird empfohlen, diese auch auszufüllen, damit die Fachhandlung direkt ein paar Informationen über den Kunden bekommt und ihn so besser zuordnen zu können.
\\ \\
Als HTTP-Methoden bekommt der Benutzer die vier üblichen Methoden, also GET um die Daten eines Benutzers zu bekommen, POST um einen Benutzer anzulegen, PUT um einen Benutzer zu bearbeiten und DELETE um ihn aus dem System zu entfernen. Nachfolgend ist ein kurzer Code-Ausschnitt der beispielhaft zeigen soll, wie man eine Liste aller Benutzer zurückgeben könnte.

\begin{lstlisting}
   app.route('/users')
      .get(function (req, res) {
         mongoose.model('users').find(function (err, users) {
            var json = {"users": users};
            res.json(json);
         });
   });
\end{lstlisting}

\subsubsection{Virtuelles Aquarium}

Die Ressource für das virtuelle Aquarium ist für die Aquarium-Daten, die von einem Benutzer eingetragen werden, gedacht. In unserer Datenbank werden sie unter der MongoDB-Collection ``aquarien'' gespeichert. Wie auch bei den Benutzern werden wir zunächst das Schema mit den Attributen des Aquariums darstellen.

\begin{lstlisting}
   aquarium{
      id: Number,
      benutzer_id: Number,
      bezeichnung: String,
      laenge: Number,
      breite: Number,
      hoehe: Number,
      fische: [{name: String, anzahl: Number}],
      pflanzen: [{name: String, anzahl: Number}],
      geraete: [{name: String, typ: String}]
   }
\end{lstlisting}

Zur eindeutigen Identifikation bekommt auch das Aquarium eine ID sowie die ID des Benutzers, der das Aquarium angelegt hat, um es diesem zuordnen zu können. Außerdem werden noch die Daten gespeichert, die der Benutzer eingetragen hat, also eine Bezeichnung des Aquariums, die Maße und den Inhalt, also Fische, Pflanzen und Geräte. Fische und Pflanzen sind jeweils Arrays, in denen verschiede Fisch- und Pflanzenarten mit deren Anzahl eingetragen werden können. Bei den Geräten muss noch ein Typ angegeben werden, also zum Beispiel ``Pumpe'', ``CO\textsubscript{2}-Aufbereitung'' oder Sonstiges. Die Aquarien werden genau wie die Benutzer die vier HTTP-Methoden bekommen. 

\subsubsection{Wasserwerte}

Die Ressource für die Wasserwerte dient zur Übermittlung der Daten von der Fachhandlung zum Benutzer. Allerdings kann auch der Benutzer selbst die Wasserwerte eintragen und bearbeiten, weshalb da unterschieden werden muss. Dazu kommt aber später noch mehr. Jetzt kommt auch hier erstmal das Schema mit den Attributen der Ressource.

\begin{lstlisting}
   wasserwerte{
      id: Number,
      benutzer_id,
      no3: String,
      po3: String,
      eisen: String,
      kalium: String,
      co2: String,
      gh: String,
      kh: String,
      ph: String
   }
\end{lstlisting}

Hier sieht man, dass wieder eine ID vergeben wird und auch die ID des betroffenen Benutzers gespeichert wird. Danach folgen die verschiedenen Werte, die jeweils als String gespeichert werden, damit zusätzlich zu dem Wert noch eine Einheit mit angegeben werden kann. Auch hier werden wieder die vier HTTP-Methoden verwendet. Allerdings gibt es hier zwei Anwendungsfälle zur Benutzung der POST- und PUT-Methode. Entweder trägt der Benutzer die Daten ein und sie werden normal in der Datenbank gespeichert oder die Fachhandlung schickt die Daten an den Benutzer. Dann muss zusätzlich über das FCM noch eine Push-Benachrichtigung an den Benutzer geschickt werden. Um dies deutlich zu machen, werden wir die POST-Methode nachfolgend als Pseudocode darstellen.

\begin{lstlisting}
   WENN(Absender ist gleich Fachhandlung)
      DANN
         Daten in DB speichern
         Token anhand der ID des Benutzers abrufen
         Push-Benachrichtigung mit Hilfe des Tokens 
         an den Benutzer schicken
   SONST
      Daten in DB speichern
\end{lstlisting}

Den Absender könnte man zum Beispiel herausfinden, indem dieser im Request-Body als Parameter mit angegeben wird.

\subsection{}